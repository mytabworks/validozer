{"version":3,"sources":["utils.js","validators.js","messages.js","index.js"],"names":["is","obj","a","toString","fnc","und","num","isNaN","validators","alpha","regexp","exe","received","length","test","numeric","email","max","parameter","parseFloat","Array","isArray","min","required","mimes","from","every","file","filename","name","split","includes","toLowerCase","alpha_space","alpha_slug","alpha_dash","alpha_num","url","max_size","parseInt","some","value","size","min_size","required_if","parameter_value","data","other_value","val","RegExp","trim","same","messages","string","array","Validozer","rulesExtend","extension","Error","Object","keys","forEach","extname","message","validator","assign","rulesUpdateMessage","validate","rules","attribute","catch_name","catch_param","catch_value","isInvalid","validation","param","TypeError","allowMessageEvenValid","messageFromstack","replace","alias","failedIn","make","instance","fails","isFail","map","label","filter","errors","Map"],"mappings":";AAAO,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EAAA,MAAMA,EAAK,CACdC,IAAMC,KAAQA,GAAW,oBAANA,GAA4C,oBAAjBA,EAAEC,WAChDC,IAAMF,GAAmB,mBAANA,EACnBG,IAAMH,QAAmB,IAANA,EACnBI,IAAMJ,IAAOK,MAAML,IAAmB,iBAANA,GAJ7B,QAAA,GAAA;;ACuIQM,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EAvIf,IAAA,EAAA,QAAA,WAEA,MAAMA,EAAa,CACfC,MAAO,CACHC,OAAQ,cACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDG,QAAS,CACLJ,IAAG,EAAC,SAACC,MACOZ,EAAGM,GAAAA,IAAIM,IAAaA,EAASC,SAAWN,MAAMK,IAI9DI,MAAO,CACHN,OAAQ,sDACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDK,IAAK,CACDN,KAAI,SAACC,EAAD,UAAWM,IACLD,MAAAA,EAAME,WAAWD,GAEhB,OAACE,MAAMC,QAAQT,IAAcL,MAAMK,GAEpCA,EAASC,QAAUD,EAASC,OAASI,EADrCE,WAAWP,GAAYK,IAKrCK,IAAK,CACDX,KAAI,SAACC,EAAD,UAAWM,IACLI,MAAAA,EAAMH,WAAWD,GAEhB,OAACE,MAAMC,QAAQT,IAAcL,MAAMK,GAEpCA,EAASC,QAAUD,EAASC,OAASS,EADrCH,WAAWP,GAAYU,IAKrCC,SAAU,CACNZ,IAAG,EAAC,SAACC,MACMZ,EAAGM,GAAAA,IAAIM,KAAqBA,EAASC,QAIpDW,MAAO,CACHb,IAAG,EAAC,SAACC,EAAD,UAAWM,MACHE,MAAMK,KAAKb,GAAUc,MAAOC,IAC1BC,MAAAA,EAAWD,EAAKE,KAAKC,MAAM,KAC1BZ,OAAAA,EAAUa,SAASH,EAASA,EAASf,OAAS,GAAGmB,kBAKpEC,YAAa,CACTvB,OAAQ,gBACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDsB,WAAY,CACRxB,OAAQ,iBACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDuB,WAAY,CACRzB,OAAQ,iBACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDwB,UAAW,CACP1B,OAAQ,gBACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpDyB,IAAK,CACD3B,OAAQ,iFACRC,KAAI,SAACC,IACMA,OAAAA,EAASC,SAAW,KAAKH,OAAOI,KAAKF,KAIpD0B,SAAU,CACN3B,KAAI,SAACC,EAAD,UAAWM,IACLoB,MAAAA,EAAWC,SAASrB,GAEtBN,OAAAA,EAASC,QACTO,MAAMK,KAAKb,GAAU4B,KAAMC,GAAUA,EAAMC,KAAO,IAAOJ,KAKrEK,SAAU,CACNhC,KAAI,SAACC,EAAD,UAAWM,IACLyB,MAAAA,EAAWJ,SAASrB,GAEtBN,OAAAA,EAASC,QACTO,MAAMK,KAAKb,GAAU4B,KAAMC,GAAUA,EAAMC,KAAO,IAAOC,KAKrEC,YAAa,CACTjC,KAAI,SAACC,EAAD,UAAWM,EAAX,gBAAsB2B,EAAtB,KAAuCC,IACjCC,MAAAA,EAAcD,EAAK5B,GAEtBE,OAAAA,MAAMC,QAAQ0B,IACLnC,EAASC,QAAUkC,EAAYP,KAClCQ,GAAQ,IAAIC,WAAWJ,EAAgBK,WAAWpC,KAAKkC,KAI3DpC,EAASC,QAAU,IAAIoC,WAAWJ,EAAgBK,WAAWpC,KAAKiC,KAK/EI,KAAM,CACFxC,IAAG,EAAC,SAACC,EAAD,UAAWM,EAAX,KAAsB4B,KACflC,EAASC,QAAUiC,EAAK5B,KAAeN,IAK3CJ,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;AC3FA4C,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EA5Cf,MAAMA,EAAW,CACb3C,MAAO,2CAEPM,QAAS,2CAETC,MAAO,wCAEPC,IAAK,CACDF,QAAS,+CACTY,KAAM,qDACN0B,OAAQ,0DACRC,MAAO,sDAGXhC,IAAK,CACDP,QAAS,uCACTY,KAAM,6CACN0B,OAAQ,kDACRC,MAAO,8CAGX/B,SAAU,oCAEVC,MAAO,oCAEPS,YAAa,mDAEbC,WAAY,qEAEZC,WAAY,gEAEZC,UAAW,uDAEXC,IAAK,sCAELC,SAAU,yDAEVK,SAAU,sDAEVC,YAAa,gEAEbO,KAAM,wCAGKC,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;ACzCgB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAH/B,IAAA,EAAA,EAAA,QAAA,iBACA,EAAA,EAAA,QAAA,eACA,EAAA,QAAA,WAC+B,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,KAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,cAAA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,0BAAA,OAAA,iBAAA,EAAA,OAAA,0BAAA,IAAA,EAAA,OAAA,IAAA,QAAA,SAAA,GAAA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,GAAA,MAAA,EAAA,MAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,QAAA,IAAA,GAAA,OAAA,UAAA,qBAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,GAAA,MAAA,EAAA,MAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,OAAA,KAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,QAAA,IAAA,IAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAAhB,MAAMG,EAAU,cAAA,EAAA,KAAA,YAAA,GAAA,EAAA,KAAA,aAAA,GAGhB,EAAA,KAAA,WAAA,IAEJC,mBAAYC,GACZ,IAACzD,EAAGC,GAAAA,IAAIwD,GACD,MAAA,IAAIC,MAAO,0BAErBC,OAAOC,KAAKH,GAAWI,QAASC,IACML,MAAAA,EAAAA,EAAUK,IAAtC,QAAEC,GAAR,EAAoBC,EAApB,EAAA,EAAA,CAAA,YACG,IAAChE,EAAGI,GAAAA,IAAI4D,EAAUrD,KACX,MAAA,IAAI+C,oEAAoEI,OAElFH,OAAOM,OAAOb,EAAd,QAAwB,CAAGU,CAAAA,GAAUC,IACrCJ,OAAOM,OAAOzD,EAAd,QAA0B,CAAGsD,CAAAA,GAAUE,MAIxCE,0BAAmBrC,EAAMkC,GACxB,IAACvD,EAAWqB,QAAAA,GACN,MAAA,IAAI6B,UAAU7B,qCAEfA,EAAAA,QAAAA,GACL7B,EAAGC,GAAAA,IAAI8D,IAAY,CAAC,MAAO,OAAOhC,SAASF,GAChCuB,EAAAA,EAAAA,GAAAA,EAASvB,QAAAA,IAAUkC,GACxBA,EAGPI,gBAASvD,EAAW,GAAIwD,EAAOC,EAAWvB,GAEzCwB,IAAAA,EAAYC,EAAaC,EACvBC,MAAAA,EAFcL,EAAMtC,MAAM,KAEFU,KAAMkC,IAC1B,MAAC7C,EAAM8C,EAAOlC,GAASiC,EAAW5C,MAAM,OAI1C,GAHJwC,EAAazC,EACb0C,EAAcI,EACdH,EAAc/B,GACTjC,EAAWqB,QAAAA,GACZ,MAAM,IAAI+C,iDACiC/C,YAAewC,OAGvD7D,OAAAA,EAAWqB,QAAAA,GAAMlB,IAAI,CACxBC,SAAAA,EACAkC,KAAAA,EACA5B,UAAWyD,GAASA,EAAM7C,MAAM,KAAK,GACrCe,gBAAiBJ,GAASA,EAAMX,MAAM,KAAK,OAI/C2C,GAAAA,GAAajE,EAAW8D,QAAAA,GAAYO,sBAAuB,CACvDC,IACAf,EADAe,EAAmB1B,EAASkB,QAAAA,IAAe9D,EAAW8D,QAAAA,GAAYP,8BAAgCO,IAgBlGC,GAdgC,oBAAhCO,EAAiB3E,aAIb2E,EAHC1D,MAAMC,QAAQT,IAAcL,MAAMK,GAER,iBAAbA,EACKkE,EAAiBzB,OAC7BjC,MAAMC,QAAQT,GACFkE,EAAiBxB,MAEjBwB,EAAiBnD,KANjBmD,EAAiB/D,SAU5CgD,EAAUe,EAAiBC,QAAQ,aAAcV,GAE7CE,EAAa,CACTA,GAAAA,EAAYxC,SAAS,KAAM,CACrB,MAAGiD,CAAAA,GAAST,EAAYzC,MAAM,KACpCyC,EAAcS,EAElBjB,EAAUA,EAAQgB,YACVT,KACHC,GAAe,IAAIQ,QAAQ,KAAM,OAItCP,GAAAA,EAAa,CACTA,GAAAA,EAAYzC,SAAS,KAAM,CACrB,MAAGiD,CAAAA,GAASR,EAAY1C,MAAM,KACpC0C,EAAcQ,EAElBjB,EAAUA,EAAQgB,QAAQ,SAAUP,GAGjC,MAAA,CACHC,UAAAA,EACAV,QAAAA,EACAkB,SAAUR,EAAYH,EAAa,MAIpC,MAAA,CAAEG,UAAAA,EAAWQ,SAAU,MAG3BC,YAAKpC,EAAMsB,GACRe,MAAAA,EAAW,IAAI5B,EAGd4B,OAFPA,EAASrC,KAAOA,EAChBqC,EAASf,MAAQA,EACVe,EAGXC,QACQC,IAAAA,GAAS,EAkBNA,OAhBFjC,KAAAA,SAAWO,OAAOC,KAAK,KAAKQ,OAC5BkB,IAAKzD,IACI,MAAA,MAAEuC,EAAF,MAASmB,GAAU,KAAKnB,MAAMvC,GAC9BsC,EAAWZ,EAAUY,SACvB,KAAKrB,KAAKjB,GACVuC,EACAmB,GAAS1D,EACT,KAAKiB,MAKF,OAHHqB,EAASM,YAAcY,IACvBA,GAAS,GAEN,CAACxD,EAAMsC,EAASJ,WAE1ByB,OAAO,EAAIzB,CAAAA,OAAeA,GAExBsB,EAGXI,SACW,OAAA,IAAIC,IAAI,KAAKtC,WA9HG,QAAA,QAAA","file":"index.js","sourceRoot":"../src/validozer","sourcesContent":["export const is = {\n    obj: (a) => !!a && a !== '[object Object]' && a.toString() === '[object Object]',\n    fnc: (a) => typeof a === 'function',\n    und: (a) => typeof a === 'undefined',\n    num: (a) => !isNaN(a) && typeof a === 'number',\n}","import {is} from './utils'\n\nconst validators = {\n    alpha: {\n        regexp: /^[A-Za-z]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    numeric: {\n        exe({received}) {\n            return (is.num(received) || received.length) && isNaN(received);\n        },\n    },\n\n    email: {\n        regexp: /^[\\w.]{2,40}@[\\w]{2,20}\\.[a-z]{2,3}(?:\\.[a-z]{2})?$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    max: {\n        exe({received, parameter}) {\n            const max = parseFloat(parameter);\n\n            return !Array.isArray(received) && !isNaN(received)\n                ? parseFloat(received) > max\n                : received.length && received.length > max;\n        },\n    },\n\n    min: {\n        exe({received, parameter}) {\n            const min = parseFloat(parameter);\n\n            return !Array.isArray(received) && !isNaN(received)\n                ? parseFloat(received) < min\n                : received.length && received.length < min;\n        },\n    },\n\n    required: {\n        exe({received}) {\n            return is.num(received) ? false : !received.length;\n        },\n    },\n\n    mimes: {\n        exe({received, parameter}) {\n            return !Array.from(received).every((file) => {\n                const filename = file.name.split('.');\n                return parameter.includes(filename[filename.length - 1].toLowerCase());\n            });\n        },\n    },\n    \n    alpha_space: {\n        regexp: /^[A-Za-z\\s]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_slug: {\n        regexp: /^[a-zA-Z\\d_]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_dash: {\n        regexp: /^[a-zA-Z\\d-]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_num: {\n        regexp: /^[a-zA-Z\\d]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    url: {\n        regexp: /^(?:https?:\\/\\/)?([a-z]{3}\\.)?([a-z]{3,20}\\.)?[\\w]{3,20}\\.[a-z]{2,3}(?:\\/.*)?$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    max_size: {\n        exe({received, parameter}) {\n            const max_size = parseInt(parameter);\n            return (\n                received.length &&\n                Array.from(received).some((value) => value.size / 1000 > max_size)\n            );\n        },\n    },\n\n    min_size: {\n        exe({received, parameter}) {\n            const min_size = parseInt(parameter);\n            return (\n                received.length &&\n                Array.from(received).some((value) => value.size / 1000 < min_size)\n            );\n        },\n    },\n\n    required_if: {\n        exe({received, parameter, parameter_value, data}) {\n            const other_value = data[parameter]\n            \n            if(Array.isArray(other_value)) {\n                return !received.length && other_value.some(\n                    (val) => new RegExp(`^${parameter_value.trim()}$`).test(val)\n                )\n            }\n            return (\n                !received.length && new RegExp(`^${parameter_value.trim()}$`).test(other_value)\n            );\n        },\n    },\n\n    same: {\n        exe({received, parameter, data}) { \n            return received.length && data[parameter] !== received;\n        },\n    },\n};\n\nexport default validators","const messages = {\n    alpha: 'The :attribute may only contain letters.',\n\n    numeric: 'The :attribute may only contain numbers.',\n\n    email: 'The :attribute must be a valid email.',\n\n    max: {\n        numeric: 'The :attribute may not be greater than :max.',\n        file: 'The :attribute may not be greater than :max files.',\n        string: 'The :attribute may not be greater than :max characters.',\n        array: 'The :attribute may not be greater than :max items.',\n    },\n\n    min: {\n        numeric: 'The :attribute must be atleast :min.',\n        file: 'The :attribute must be atleast :min files.',\n        string: 'The :attribute must be atleast :min characters.',\n        array: 'The :attribute must be atleast :min items.',\n    },\n\n    required: 'The :attribute field is required.',\n\n    mimes: 'The :attribute only allow :mimes.',\n    \n    alpha_space: 'The :attribute must contain letters with spaces.',\n\n    alpha_slug: 'The :attribute may only contain letters, numbers, and underscores.',\n\n    alpha_dash: 'The :attribute may only contain letters, numbers, and dashes.',\n\n    alpha_num: 'The :attribute may only contain letters and numbers.',\n\n    url: 'The :attribute must be a valid url.',\n\n    max_size: 'The :attribute may not be greater :max_size kilobytes.',\n\n    min_size: 'The :attribute must be atleast :min_size kilobytes.',\n\n    required_if: 'The :attribute field is required when :required_if is :value.',\n\n    same: 'The :attribute and :same must match.',\n};\n\nexport default messages","import validators from './validators';\nimport messages from './messages';\nimport { is } from './utils';\nexport default class Validozer {\n    data;\n    rules;\n    messages = [] \n\n    static rulesExtend(extension) {\n        if(!is.obj(extension)) {\n            throw new Error(`Invalid rule extention`);\n        }\n        Object.keys(extension).forEach((extname) => {\n            const { message, ...validator } = extension[extname]\n            if(!is.fnc(validator.exe)) {\n                throw new Error(`Invalid rule extention method \\`exe\\` is missing in rule \\`${extname}\\``);\n            }\n            Object.assign(messages, { [extname]: message });\n            Object.assign(validators, { [extname]: validator });\n        })\n    }\n    \n    static rulesUpdateMessage(name, message) {\n        if (!validators[name]) {\n            throw new Error(`\"${name}\" is not part of Validozer rules`);\n        }\n        messages[name] =\n            is.obj(message) && ['min', 'max'].includes(name)\n                ? { ...messages[name], ...message }\n                : message;\n    }\n    \n    static validate(received = \"\", rules, attribute, data) {\n        const array_rules = rules.split('|');\n        let catch_name, catch_param, catch_value;\n        const isInvalid = array_rules.some((validation) => { \n            const [name, param, value] = validation.split(/:|=/);\n            catch_name = name;\n            catch_param = param;\n            catch_value = value;\n            if (!validators[name])\n                throw new TypeError(\n                    `Validozer does not recognize rule \\`${name}\\` in \\`${attribute}\\``\n                ); \n\n            return validators[name].exe({ \n                received, \n                data,\n                parameter: param && param.split('@')[0],\n                parameter_value: value && value.split('@')[0],\n            })\n        });\n    \n        if (isInvalid || validators[catch_name].allowMessageEvenValid) {\n            let messageFromstack = messages[catch_name] || validators[catch_name].message || `The :attribute is ${catch_name}`;\n            let message;\n            if (messageFromstack.toString() === '[object Object]') {\n                if (!Array.isArray(received) && !isNaN(received)) {\n                    messageFromstack = messageFromstack.numeric;\n                } else if (typeof received === 'string') {\n                    messageFromstack = messageFromstack.string;\n                } else if (Array.isArray(received)) {\n                    messageFromstack = messageFromstack.array;\n                } else {\n                    messageFromstack = messageFromstack.file;\n                }\n            }\n    \n            message = messageFromstack.replace(':attribute', attribute);\n    \n            if (catch_param) {\n                if (catch_param.includes('@')) {\n                    const [, alias] = catch_param.split('@');\n                    catch_param = alias;\n                }\n                message = message.replace(\n                    `:${catch_name}`,\n                    (catch_param || '').replace(/,/g, ', ')\n                );\n            }\n    \n            if (catch_value) {\n                if (catch_value.includes('@')) {\n                    const [, alias] = catch_value.split('@');\n                    catch_value = alias;\n                }\n                message = message.replace(':value', catch_value);\n            }\n    \n            return {\n                isInvalid,\n                message,\n                failedIn: isInvalid ? catch_name : null,\n            };\n        }\n    \n        return { isInvalid, failedIn: null };\n    }\n\n    static make(data, rules) {\n        const instance = new Validozer() \n        instance.data = data\n        instance.rules = rules\n        return instance\n    }\n\n    fails() {\n        let isFail = false;\n\n        this.messages = Object.keys(this.rules)\n            .map((name) => {\n                const { rules, label } = this.rules[name];\n                const validate = Validozer.validate(\n                    this.data[name],\n                    rules,\n                    label || name,\n                    this.data\n                );\n                if (validate.isInvalid && !isFail) {\n                    isFail = true;\n                }\n                return [name, validate.message];\n            })\n            .filter(([, message]) => !!message);\n\n        return isFail;\n    }\n\n    errors() {\n        return new Map(this.messages);\n    }\n}\n"]}