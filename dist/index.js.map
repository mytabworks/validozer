{"version":3,"sources":["validators.js","messages.js","utils.js","index.js"],"names":["validators","alpha","regexp","exe","received","length","test","numeric","isNaN","email","max","parameter","parseFloat","Array","isArray","min","required","mimes","from","every","file","filename","name","split","includes","toLowerCase","alpha_space","alpha_slug","alpha_dash","alpha_num","url","max_size","parseInt","some","value","size","min_size","required_if","parameter_value","data","other_value","val","RegExp","trim","same","messages","string","array","is","obj","a","toString","fnc","Validozer","rulesExtend","extension","Error","Object","keys","forEach","extname","message","validator","assign","rulesUpdateMessage","validate","rules","attribute","catch_name","catch_param","catch_value","isInvalid","validation","param","TypeError","allowMessageEvenValid","messageFromstack","replace","alias","failedIn","make","instance","fails","isFail","map","label","filter","errors","Map"],"mappings":"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","file":"index.js","sourceRoot":"../src/validozer","sourcesContent":["const validators = {\n    alpha: {\n        regexp: /^[A-Za-z]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    numeric: {\n        exe({received}) {\n            return received.length && isNaN(received);\n        },\n    },\n\n    email: {\n        regexp: /^[\\w.]{2,40}@[\\w]{2,20}\\.[a-z]{2,3}(?:\\.[a-z]{2})?$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    max: {\n        exe({received, parameter}) {\n            const max = parseFloat(parameter);\n\n            return !Array.isArray(received) && !isNaN(received)\n                ? received && parseFloat(received) > max\n                : received.length && received.length > max;\n        },\n    },\n\n    min: {\n        exe({received, parameter}) {\n            const min = parseFloat(parameter);\n\n            return !Array.isArray(received) && !isNaN(received)\n                ? received && parseFloat(received) < min\n                : received.length && received.length < min;\n        },\n    },\n\n    required: {\n        exe({received}) {\n            return !received.length;\n        },\n    },\n\n    mimes: {\n        exe({received, parameter}) {\n            return !Array.from(received).every((file) => {\n                const filename = file.name.split('.');\n                return parameter.includes(filename[filename.length - 1].toLowerCase());\n            });\n        },\n    },\n    \n    alpha_space: {\n        regexp: /^[A-Za-z\\s]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_slug: {\n        regexp: /^[a-zA-Z\\d_]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_dash: {\n        regexp: /^[a-zA-Z\\d-]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    alpha_num: {\n        regexp: /^[a-zA-Z\\d]+$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    url: {\n        regexp: /^(?:https?:\\/\\/)?([a-z]{3}\\.)?([a-z]{3,20}\\.)?[\\w]{3,20}\\.[a-z]{2,3}(?:\\/.*)?$/,\n        exe({received}) {\n            return received.length && !this.regexp.test(received);\n        },\n    },\n\n    max_size: {\n        exe({received, parameter}) {\n            const max_size = parseInt(parameter);\n            return (\n                received.length &&\n                Array.from(received).some((value) => value.size / 1000 > max_size)\n            );\n        },\n    },\n\n    min_size: {\n        exe({received, parameter}) {\n            const min_size = parseInt(parameter);\n            return (\n                received.length &&\n                Array.from(received).some((value) => value.size / 1000 < min_size)\n            );\n        },\n    },\n\n    required_if: {\n        exe({received, parameter, parameter_value, data}) {\n            const other_value = data[parameter]\n            \n            if(Array.isArray(other_value)) {\n                return !received.length && other_value.some(\n                    (val) => new RegExp(`^${parameter_value.trim()}$`).test(val)\n                )\n            }\n            return (\n                !received.length && new RegExp(`^${parameter_value.trim()}$`).test(other_value)\n            );\n        },\n    },\n\n    same: {\n        exe({received, parameter, data}) { \n            return received.length && data[parameter] !== received;\n        },\n    },\n};\n\nexport default validators","const messages = {\n    alpha: 'The :attribute may only contain letters.',\n\n    numeric: 'The :attribute may only contain numbers.',\n\n    email: 'The :attribute must be a valid email.',\n\n    max: {\n        numeric: 'The :attribute may not be greater than :max.',\n        file: 'The :attribute may not be greater than :max files.',\n        string: 'The :attribute may not be greater than :max characters.',\n        array: 'The :attribute may not be greater than :max items.',\n    },\n\n    min: {\n        numeric: 'The :attribute must be atleast :min.',\n        file: 'The :attribute must be atleast :min files.',\n        string: 'The :attribute must be atleast :min characters.',\n        array: 'The :attribute must be atleast :min items.',\n    },\n\n    required: 'The :attribute field is required.',\n\n    mimes: 'The :attribute only allow :mimes.',\n    \n    alpha_space: 'The :attribute must contain letters with spaces.',\n\n    alpha_slug: 'The :attribute may only contain letters, numbers, and underscores.',\n\n    alpha_dash: 'The :attribute may only contain letters, numbers, and dashes.',\n\n    alpha_num: 'The :attribute may only contain letters and numbers.',\n\n    url: 'The :attribute must be a valid url.',\n\n    max_size: 'The :attribute may not be greater :max_size kilobytes.',\n\n    min_size: 'The :attribute must be atleast :min_size kilobytes.',\n\n    required_if: 'The :attribute field is required when :required_if is :value.',\n\n    same: 'The :attribute and :same must match.',\n};\n\nexport default messages","export const is = {\n    obj: (a) => !!a && a !== '[object Object]' && a.toString() === '[object Object]',\n    fnc: (a) => typeof a === 'function'\n}","import validators from './validators';\nimport messages from './messages';\nimport { is } from './utils';\nexport default class Validozer {\n    data;\n    rules;\n    messages = [] \n\n    static rulesExtend(extension) {\n        if(!is.obj(extension)) {\n            throw new Error(`Invalid rule extention`);\n        }\n        Object.keys(extension).forEach((extname) => {\n            const { message, ...validator } = extension[extname]\n            if(!is.fnc(validator.exe)) {\n                throw new Error(`Invalid rule extention method \\`exe\\` is missing in rule \\`${extname}\\``);\n            }\n            Object.assign(messages, { [extname]: message });\n            Object.assign(validators, { [extname]: validator });\n        })\n    }\n    \n    static rulesUpdateMessage(name, message) {\n        if (!validators[name]) {\n            throw new Error(`\"${name}\" is not part of Validozer rules`);\n        }\n        messages[name] =\n            is.obj(message) && ['min', 'max'].includes(name)\n                ? { ...messages[name], ...message }\n                : message;\n    }\n    \n    static validate(received, rules, attribute, data) {\n        const array_rules = rules.split('|');\n        let catch_name, catch_param, catch_value;\n        const isInvalid = array_rules.some((validation) => { \n            const [name, param, value] = validation.split(/:|=/);\n            catch_name = name;\n            catch_param = param;\n            catch_value = value;\n            if (!validators[name])\n                throw new TypeError(\n                    `Validozer does not recognize rule \\`${name}\\` in \\`${attribute}\\``\n                ); \n\n            return validators[name].exe({ \n                received, \n                data,\n                parameter: param && param.split('@')[0],\n                parameter_value: value && value.split('@')[0],\n            })\n        });\n    \n        if (isInvalid || validators[catch_name].allowMessageEvenValid) {\n            let messageFromstack = messages[catch_name] || validators[catch_name].message || `The :attribute is ${catch_name}`;\n            let message;\n            if (messageFromstack.toString() === '[object Object]') {\n                if (!Array.isArray(received) && !isNaN(received)) {\n                    messageFromstack = messageFromstack.numeric;\n                } else if (typeof received === 'string') {\n                    messageFromstack = messageFromstack.string;\n                } else if (Array.isArray(received)) {\n                    messageFromstack = messageFromstack.array;\n                } else {\n                    messageFromstack = messageFromstack.file;\n                }\n            }\n    \n            message = messageFromstack.replace(':attribute', attribute);\n    \n            if (catch_param) {\n                if (catch_param.includes('@')) {\n                    const [, alias] = catch_param.split('@');\n                    catch_param = alias;\n                }\n                message = message.replace(\n                    `:${catch_name}`,\n                    (catch_param || '').replace(/,/g, ', ')\n                );\n            }\n    \n            if (catch_value) {\n                if (catch_value.includes('@')) {\n                    const [, alias] = catch_value.split('@');\n                    catch_value = alias;\n                }\n                message = message.replace(':value', catch_value);\n            }\n    \n            return {\n                isInvalid,\n                message,\n                failedIn: isInvalid ? catch_name : null,\n            };\n        }\n    \n        return { isInvalid, failedIn: null };\n    }\n\n    static make(data, rules) {\n        const instance = new Validozer() \n        instance.data = data\n        instance.rules = rules\n        return instance\n    }\n\n    fails() {\n        let isFail = false;\n\n        this.messages = Object.keys(this.rules)\n            .map((name) => {\n                const { rules, label } = this.rules[name];\n                const validate = Validozer.validate(\n                    this.data[name],\n                    rules,\n                    label || name,\n                    this.data\n                );\n                if (validate.isInvalid && !isFail) {\n                    isFail = true;\n                }\n                return [name, validate.message];\n            })\n            .filter(([, message]) => !!message);\n\n        return isFail;\n    }\n\n    errors() {\n        return new Map(this.messages);\n    }\n}\n"]}